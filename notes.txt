TODO remove from project structure

loses zeug -----------------------------

wie könnte ein monitoring fall aussehen, der den algorithmus beobachtet?
    vielleicht eine größere zahl kugeln, die auf einer achse liegen und von einer angestoßen werden
    oder einfacher: ein frame vor kollision, dann overlap durch pos+vel, um koll erk. und antw. zu testen

Interface Tests sollen immer mehrere Sphere Manipulations-Methoden betreffen

DOK:
1: Beschreib
-SCREENSHOTS, QUELLEN
-in der DOK und in Code-comments werden "Raum", "Welt" und "System" synonym verwendet
-airDensity sollte korrekter "roomMediumDensity" oder so heißen, ich habe den intuitiveren Namen gewählt
-Zu Immutability: Mehrere Java-Objekte vom Typ Shape können "derselbe Körper" sein (→ id, ...)
-mit anderen formen im Sinn strukturiert, Implementierung würde aber Rahmen sprengen
-anmerken (in DOK(?)), dass Vector3D immutabel ist
-Anzahl Objekte * Genauigkeitsversprechen ~ Rechenintensität
-Features
    -...
-Näherungen
    -Punktmassen
    -keine Rotation
    -Kollisionen werden nacheinander zwischen je 2 Körpern berechnet
    -Gravitation durch andere Körper hat konstante Beschleunigung in einem timeStep
    -keine Reibung bei Kollision oder andere thermischen Verluste
        -aber Strömungswiderstand
            -hat konstante Beschleunigung in einem timeStep & ist reaktiv (nutzt "alte" vel)
2: Algo
-ich nutze CCD, finde Zeitpunkt der Kollision und passe pos&vel an
-simulateChanges(): Jede Manipulation (durch stream.map realisiert) gibt eine neue Liste von Körpern zurück, welche den Zustand nach der jeweiligen Manip. darstellen
        -dadurch kann man vorherige Zustände ganz einfach in späteren Berechnungen übergeben (danke immutability)
3: Logging zeigt Richtigkeit von Algo
-LOGGING-PROTOKOLL beilegen


-use randompos for slightly offset batch spawn
	V3 p = world.randomPos(world.getSize().getX()/1.9).add(new V3(0,0.3,0));

VAL:
5 Tests AL-Interface
-worldGravity
-entityGravity (?Kreisbahn mit perfekter Umrundung auf Ankunftsort nach 2pi testen)
-wallCollision (testet auch Bew. mit konstanter vel)
-entityCollision (mit Impulserhaltung)
-????reibung
5 Tests AL-Klassen
-einzelne Shape methods testen
-????Immutabilitätstest
Logging (toggleable)
- World::simulateChanges "updating world (timeStep = __s)"
- spheres: name logs after (type &) id (and make individual output files, if making file output?)


Eigenbeschleunigung: Damit lässt sich z.B. gut simulieren, wie ein beschleunigtes Objekt auf ein ruhendes trifft.
    "wirkt wie ein homogenes Kraftfeld, das allerdings nur auf einen Körper wirkt."


Quellen:
https://en.wikipedia.org/wiki/Physics_engine
(drag)
    https://www.leifiphysik.de/mechanik/stroemungslehre/grundwissen/stroemungswiderstand-und-crmw-wert
(entity collision deflection angle)
    https://en.wikipedia.org/wiki/Elastic_collision
    (not needed?) https://stackoverflow.com/a/3255204
    (for unit tests) https://www.leifiphysik.de/mechanik/impulserhaltung-und-stoesse/grundwissen/zentraler-elastischer-stoss
(if cuboids w/ AABB)
    https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection
(time-based simulation display)
    https://www.isaacsukin.com/news/2015/01/detailed-explanation-javascript-game-loops-and-timing
(für IL)
    https://www.leifiphysik.de/mechanik/kreisbewegung/grundwissen/zentripetalkraft
(IL bsp szenarien)
    https://de.wikipedia.org/wiki/Poolbillard
    https://billiards.colostate.edu/faq/speed/typical/
------------------ not used any longer (?) -----------------------------------------------------------------------------



Libraries:
https://commons.apache.org/proper/commons-math/
https://www.eclipse.org/collections/


Parts
(PRD)
(VAL)
DOK
IND
- alle TODOS durcharbeiten


DEV --------

IL
-time based updates
-CompletableFuture

AL
-selfAcc rausnehmen???? !
    -alternatively: entitycoll: von selfAcc bleibt nur noch acc_orthogonal_zu_posDiff
-fix für "obenhalten" durch Kollision, trotz world gravity


/ loses zeug ---------------------------


DEMONSTRATION / ABNAHME:

-?mit MMB auf World klicken, um zu zeigen, dass es nicht illegal in IL verwendet wird


--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
Dokumentation:
---
Kurzbeschreibung:


Algorithmus:


Szenario:


--------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
Konzept:

Anwendung:
Ich möchte eine Physics Engine programmieren, die dreidimensionale Körper,
ihre Bewegungen und Interaktionen in einem Raum simuliert.
Die Engine soll möglichst realistisch sein, aber einige Konzepte auf ein intuitives Level reduzieren.
Zunächst werde ich mich auf Kugeln fokussieren, da sie das einfachste Kollisionsverhalten haben
und an ihnen auch eine Umsetzung komplexerer Eigenschaften wie Rotation oder Reibung realistisch scheint.
Als User hat man eine 3D-Ansicht der "Welt" sowie ein Control Panel,
das Informationen anzeigt und Möglichkeiten zur Manipulation der Ansicht & Welt besitzt.
In der Welt soll darüber mindestens möglich sein:
    - Neuen Körper mit Eigenschaften erschaffen
    - Körper zerstören
    - Zeit fortschreiten lassen und Änderungen simulieren

--------------------------------------------------------------------------------------------
Algorithmus:
Der Algorithmus, der zum Einsatz kommen soll, führt einen Zeitschritt im physikalischen System aus
("update"-Methode) und erledigt alle Berechnungen der Änderungen im System.
Die Rechenintensität entsteht durch viele Objekte in der Welt, die interagieren können,
sowie die Anzahl und Komplexität der physikalischen Phänomene, die eingebunden werden.
Für jeden vorhandenen Körper müssen u.a.
    - Bewegungsgleichungen
    - Kräfte mit Wirkung auf Bewegung
    - Kollisionserkennungen und -antworten mit Wänden und jedem anderen Körper (inklusive Impulserhaltung)
berechnet werden.
Der Algorithmus versucht, möglichst parallelisiert zu arbeiten, um effizient zu sein.
Einige Schritte bauen jedoch auf vorherigen auf oder müssen Informationen über Objekte zwischenspeichern,
daher ist ein kluges Zusammenspiel der verschiedenen Schritte erforderlich.
