loses zeug -----------------------------

wie könnte ein monitoring fall aussehen, der den algorithmus beobachtet?
    vielleicht eine größere zahl kugeln, die auf einer achse liegen und von einer angestoßen werden
    oder einfacher: ein frame vor kollision, dann overlap durch pos+vel, um koll erk. und antw. zu testen


DOK:
-Zu Immutability: Mehrere Java-Objekte vom Typ Shape können "derselbe Körper" sein (→ id, ...)
-mit anderen formen im Sinn strukturiert, Implementierung würde aber Rahmen sprengen
-anmerken (in DOK(?)), dass Vector3D immutabel ist
-Anzahl Objekte * Genauigkeitsversprechen ~ Rechenintensität
-Näherungen
    -Punktmassen
    -keine Rotation
    -keine Reibung oder andere thermischen Verluste
    -Gravitation durch andere Körper hat konstante Beschleunigung in einem timeStep
    -Kollisionen werden nacheinander zwischen je 2 Körpern berechnet

-use randompos for slightly offset batch spawn
	V3 p = world.randomPos(world.getSize().getX()/1.9).add(new V3(0,0.3,0));

VAL:
5 Tests AL-Interface
-worldGravity
-entityGravity (?Kreisbahn mit perfekter Umrundung auf Ankunftsort nach 2pi testen)
-wallCollision (testet auch Bew. mit konstanter vel)
-entityCollision (mit Impulserhaltung)
-????reibung
5 Tests AL-Klassen
-einzelne Shape methods testen
-????Immutabilitätstest
Logging (toggleable)
- World::simulateChanges "updating world (timeStep = __s)"
- spheres: name logs after (type &) id (and make individual output files, if making file output?)


Eigenbeschleunigung: Damit lässt sich Zeug simulieren. Enthält keine
    -"eigenbeschleunigung: wird nicht durch kraftfeld o.Ä. erzeugt, demnach ist es wie ein Triebwerk,
das Energie zur Beschl. bereitstellt. Daher habe ich mich entschieden,
diese Beschleunigung durch Kollisionen auf 0 zu setzen, denn IRL beschleunigen Objekte
(Autos, Pistolenkugeln etc.) auch nicht mehr weiter, nachdem sie kollidiert sind.
Externe Beschl. (Gravitation) wirken natürlich weiter"


Quellen:
https://en.wikipedia.org/wiki/Physics_engine
(entity collision deflection angle)
    https://en.wikipedia.org/wiki/Elastic_collision
    (not needed?) https://stackoverflow.com/a/3255204
(if cuboids w/ AABB)
    https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection
(time-based simulation display)
    https://www.isaacsukin.com/news/2015/01/detailed-explanation-javascript-game-loops-and-timing
(für IL)
    https://www.leifiphysik.de/mechanik/kreisbewegung/grundwissen/zentripetalkraft
------------------ not used any longer (?) -----------------------------------------------------------------------------
https://www.leifiphysik.de/mechanik/impulserhaltung-und-stoesse/grundwissen/zentraler-elastischer-stoss



Libraries:
https://commons.apache.org/proper/commons-math/
https://www.eclipse.org/collections/


TODO --------
(PRD)
VAL
DOK
IND
- alle TODOS durcharbeiten


DEV --------

IL
-mass or density user input

AL
-selfAcc rausnehmen???? !
    -alternatively: entitycoll: von selfAcc bleibt nur noch acc_orthogonal_zu_posDiff


/ loses zeug ---------------------------


DEMONSTRATION / ABNAHME:

-?mit MMB auf World klicken, um zu zeigen, dass es nicht illegal in IL verwendet wird


--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
Dokumentation:
---
Kurzbeschreibung:


Algorithmus:


Szenario:


--------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
Konzept:

Anwendung:
Ich möchte eine Physics Engine programmieren, die dreidimensionale Körper,
ihre Bewegungen und Interaktionen in einem Raum simuliert.
Die Engine soll möglichst realistisch sein, aber einige Konzepte auf ein intuitives Level reduzieren.
Zunächst werde ich mich auf Kugeln fokussieren, da sie das einfachste Kollisionsverhalten haben
und an ihnen auch eine Umsetzung komplexerer Eigenschaften wie Rotation oder Reibung realistisch scheint.
Als User hat man eine 3D-Ansicht der "Welt" sowie ein Control Panel,
das Informationen anzeigt und Möglichkeiten zur Manipulation der Ansicht & Welt besitzt.
In der Welt soll darüber mindestens möglich sein:
    - Neuen Körper mit Eigenschaften erschaffen
    - Körper zerstören
    - Zeit fortschreiten lassen und Änderungen simulieren

--------------------------------------------------------------------------------------------
Algorithmus:
Der Algorithmus, der zum Einsatz kommen soll, führt einen Zeitschritt im physikalischen System aus
("update"-Methode) und erledigt alle Berechnungen der Änderungen im System.
Die Rechenintensität entsteht durch viele Objekte in der Welt, die interagieren können,
sowie die Anzahl und Komplexität der physikalischen Phänomene, die eingebunden werden.
Für jeden vorhandenen Körper müssen u.a.
    - Bewegungsgleichungen
    - Kräfte mit Wirkung auf Bewegung
    - Kollisionserkennungen und -antworten mit Wänden und jedem anderen Körper (inklusive Impulserhaltung)
berechnet werden.
Der Algorithmus versucht, möglichst parallelisiert zu arbeiten, um effizient zu sein.
Einige Schritte bauen jedoch auf vorherigen auf oder müssen Informationen über Objekte zwischenspeichern,
daher ist ein kluges Zusammenspiel der verschiedenen Schritte erforderlich.
